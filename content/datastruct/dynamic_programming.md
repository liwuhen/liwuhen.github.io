---
title: "动态规划"
date: 2024-01-30T01:44:57Z
draft: false
author: 李双双
tags:
image:
description:
toc:
---

## 一 状态机DP
#### 1.1 打家劫舍
题目：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
    
    示例 1：
        输入：[1,2,3,1]
        输出：4
        解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
            偷窃到的最高金额 = 1 + 3 = 4 。
    示例 2：
        输入：[2,7,9,3,1]
        输出：12
        解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，
            接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。
    提示：
        1 <= nums.length <= 100
        0 <= nums[i] <= 400

分析：此题考虑偷某个房屋和相邻的房屋有关系，例如示例1最后一个房屋和前一房屋有关，当前房屋偷与不偷取决于 前一个房屋和前两个房屋是否被偷了。因此，抽象理解当前状态和前面状态会有一种依赖关系，一般考虑动态规划。

    考虑动规五步曲：
    1）dp数组的含义：dp[i]，考虑当前房屋i（包含i之前的房屋）,偷窃的最高金额。
    2）递推公式：如何通过历史状态递推出当前状态dp[i]。当前第i的房屋分为2种状态：选与不选？
        a）选，选i房屋时，最大金额 = dp[i-2] + nums[i]。
        b)不选，不选i房屋时，最大金额 = dp[i-1]。
        这里dp[i-1]表示考虑i-1房屋即i-1之前房屋的最大金额，具体偷不偷不一定。 
       递推公式：dp[i] = max(dp[i-2]+nums[i], dp[i-1]);
    3) dp数组初始化：dp[0] = nums[0], 只考虑第一个房屋，最大值为nums[0], 
    dp[1] = max(nums[0], nums[1]),因为对于第2房屋，并不一定偷，若不偷的可能偷1房屋，因此选最大。
    4) 确定遍历顺序: 由于当前状态与历史状态有关，因此需要i从小到大开始遍历。
<details>
<summary><font size="4" color="orange">Show Code</font></summary> 

``` c++
class Solution {
public:
    int rob(vector<int>& nums) {
       if (nums.size() == 0) return 0;
       if (nums.size() == 1) return nums[0];
       
       vector<int> dp(nums.size()+1, 0);
       dp[0] = nums[0];
       dp[1] = max(nums[0], nums[1]);

       for (int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i-2] + nums[i], dp[i-1]);
       }

       return dp[nums.size()-1];
    }
};
```
</details>

## 二 线性DP
#### 2.1 打家劫舍||
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

    示例 1：
        输入：nums = [2,3,2]
        输出：3
        解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
    示例 2：
        输入：nums = [1,2,3,1]
        输出：4
        解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
            偷窃到的最高金额 = 1 + 3 = 4 。
    示例 3：
        输入：nums = [1,2,3]
        输出：3
    提示：
        1 <= nums.length <= 100
        0 <= nums[i] <= 1000

分析：此题由于房屋的成环，说明题目所给数组为环状，若要所偷的金额最大，分为3种情况，第一种不考虑第一个房屋和最后一个房屋，此时为线性数组。第二种为考虑第一个房屋，不考虑最后一个房屋，第三种为考虑最后一个房屋，不考虑第一个房屋。（此种考虑是因为环形数组第一个与最后一个相同）

    考虑动规五步曲：
    1）dp数组的含义：dp[i]，考虑当前房屋i（包含i之前的房屋）,偷窃的最高金额。
    2）递推公式：如何通过历史状态递推出当前状态dp[i]。当前第i的房屋分为2种状态：选与不选？
        a）选，选i房屋时，最大金额 = dp[i-2] + nums[i]。
        b)不选，不选i房屋时，最大金额 = dp[i-1]。
        这里dp[i-1]表示考虑i-1房屋即i-1之前房屋的最大金额，具体偷不偷不一定。 
       递推公式：dp[i] = max(dp[i-2]+nums[i], dp[i-1]);
    3) dp数组初始化：dp[0] = nums[0], 只考虑第一个房屋，最大值为nums[0], 
    dp[1] = max(nums[0], nums[1]),因为对于第2房屋，并不一定偷，若不偷的可能偷1房屋，因此选最大。
    4) 确定遍历顺序: 由于当前状态与历史状态有关，因此需要i从小到大开始遍历。

<details>
<summary><font size="4" color="orange">Show Code</font></summary> 

``` c++
class Solution {
public:
    int rob(vector<int>& nums) {
       if (nums.size() == 0) return 0;
       if (nums.size() == 1) return nums[0];

       int result   = robv1(nums, 0, nums.size() - 2);
       int resultv1 = robv1(nums, 1, nums.size() - 1);
       return max(result, resultv1); 
    }

    int robv1(vector<int>& nums, int start, int end) {
        if (start == end) return nums[start];
        vector<int> dp(nums.size()+1, 0);
        dp[start] = nums[start];
        dp[start+1] = max(nums[start], nums[start+1]);
        for (int i = start + 2; i <= end; i++) {
            dp[i] = max(dp[i-2] + nums[i], dp[i-1]);
        }

        return dp[end];
        
    }
};
```
</details>

## 三 树形DP
#### 3.1 
小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。

除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。

给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。

    示例 1:
        输入: root = [3,2,3,null,3,null,1]
        输出: 7 
        解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
    示例 2:
        输入: root = [3,4,5,1,3,null,1]
        输出: 9
        解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9
    提示：
        树的节点数在 [1, 104] 范围内
        0 <= Node.val <= 104

分析：此题由于房屋的成环，说明题目所给数组为环状，若要所偷的金额最大，分为3种情况，第一种不考虑第一个房屋和最后一个房屋，此时为线性数组。第二种为考虑第一个房屋，不考虑最后一个房屋，第三种为考虑最后一个房屋，不考虑第一个房屋。（此种考虑是因为环形数组第一个与最后一个相同）

    考虑动规五步曲：
    1）dp数组的含义：dp[i]，考虑当前房屋i（包含i之前的房屋）,偷窃的最高金额。
    2）递推公式：如何通过历史状态递推出当前状态dp[i]。当前第i的房屋分为2种状态：选与不选？
        a）选，选i房屋时，最大金额 = dp[i-2] + nums[i]。
        b)不选，不选i房屋时，最大金额 = dp[i-1]。
        这里dp[i-1]表示考虑i-1房屋即i-1之前房屋的最大金额，具体偷不偷不一定。 
       递推公式：dp[i] = max(dp[i-2]+nums[i], dp[i-1]);
    3) dp数组初始化：dp[0] = nums[0], 只考虑第一个房屋，最大值为nums[0], 
    dp[1] = max(nums[0], nums[1]),因为对于第2房屋，并不一定偷，若不偷的可能偷1房屋，因此选最大。
    4) 确定遍历顺序: 由于当前状态与历史状态有关，因此需要i从小到大开始遍历。


## 四 股票问题
#### 4.1 买卖股票的最佳时机
题目：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

    示例 1：
        输入：[7,1,5,3,6,4]
        输出：5
        解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
            注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
    示例 2：
        输入：prices = [7,6,4,3,1]
        输出：0
        解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
    提示：
        1 <= prices.length <= 105
        0 <= prices[i] <= 104

分析：股票对于某天就两种状态，持有股票和不持有股票，再加上“某天”这个维度，所以状态有两个：某天与是否持有；用一个二维数组就可以表示所有天数的情况。

    考虑动规五步曲：
    1）dp数组的含义：dp[i][0]-第i天手里持有股票的状态。有两种情况，
       第一种一直没买过股票，第i天买入这个股票，
       第二种是第i天之前已经买入了这个股票，一直持有到第i天。
       dp[i][1]-第i天手里不持有股票的状态。有三种情况，
       第一种一直没有买过这个股票（理解为i-1天不持有），第二种第i天之前买入了，第i天卖出，（理解为i-1天持有）
       第三种第i天之前，已经买入与卖出了这支股票。（理解为i-1天不持有）
    2）递推公式：如何通过历史状态递推出当前状态dp[i]。
        dp[i][0]-第i天手里持有股票的状态2种状态：
        a）第一种，最大利润 - prices[i]。
        b）第二种，最大利润 dp[i-1][0]。
        最大利润：dp[i][0] = max(- prices[i], dp[i-1][0])。
        dp[i][1]-第i天手里不持有股票的状态3种状态:
        a）第一种，最大利润 dp[i-1][1]。
        b）第二种，最大利润 dp[i-1][0] + prices[i]。
        c）第三种，最大利润 dp[i-1][1]。
       递推公式：dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
    3) dp数组初始化：dp[0][0] = -prices[0](初始最大利润为0,第一天持有，说明为第一天买入，因此为负数), 
       dp[0][1] = 0;
    4) 确定遍历顺序: 由于当前状态与历史状态有关，因此需要i从小到大开始遍历。

<details>
<summary><font size="4" color="orange">Show Code</font></summary> 

``` c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {

       if (prices.empty()) return 0; 

       vector<vector<int>>dp(prices.size()+1, vector<int>(2));

       dp[0][0] = -prices[0];
       dp[0][1] = 0;

       for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = max(-prices[i], dp[i-1][0]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
       }

       return max(dp[prices.size()-1][0], dp[prices.size()-1][1]);
    }
};
```
</details>


#### 4.2 买卖股票的最佳时机II
题目：给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。

返回你能获得的最大利润 。

    示例 1：
        输入：prices = [7,1,5,3,6,4]
        输出：7
        解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 
            这笔交易所能获得利润 = 5 - 1 = 4 。
            随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 
            这笔交易所能获得利润 = 6 - 3 = 3 。
            总利润为 4 + 3 = 7 。
    示例 2：
        输入：prices = [1,2,3,4,5]
        输出：4
        解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出,
        这笔交易所能获得利润 = 5 - 1 = 4 。总利润为 4 。
    示例 3：
        输入：prices = [7,6,4,3,1]
        输出：0
        解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
        提示：
        1 <= prices.length <= 3 * 104
        0 <= prices[i] <= 104

分析：股票对于某天就两种状态，持有股票和不持有股票，再加上“某天”这个维度，所以状态有两个：某天与是否持有；用一个二维数组就可以表示所有天数的情况。

    考虑动规五步曲：
    1）dp数组的含义：dp[i][0]-第i天手里持有股票的状态。有两种情况，
       第一种第i天买入这个股票，i-1之前可能交易过，（理解为i-1天不持有）
       第二种是第i天之前已经买入了这个股票，一直持有到第i天。（理解为i-1天持有）
       dp[i][1]-第i天手里不持有股票的状态。有三种情况，
       第一种一直没有买过这个股票（理解为i-1天不持有），第二种第i天之前买入了，第i天卖出，（理解为i-1天持有）
       第三种第i天之前，已经买入与卖出了这支股票。（理解为i-1天不持有）
    2）递推公式：如何通过历史状态递推出当前状态dp[i]。
        dp[i][0]-第i天手里持有股票的状态2种状态：
        a）第一种，最大利润 dp[i-1][1] - prices[i]。
        b）第二种，最大利润 dp[i-1][0]。
        最大利润：dp[i][0] = max(dp[i-1][1] - prices[i], dp[i-1][0])。
        dp[i][1]-第i天手里不持有股票的状态3种状态:
        a）第一种，最大利润 dp[i-1][1]。
        b）第二种，最大利润 dp[i-1][0] + prices[i]。
        c）第三种，最大利润 dp[i-1][1]。
       递推公式：dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
    3) dp数组初始化：dp[0][0] = -prices[0](初始最大利润为0,第一天持有，说明为第一天买入，因此为负数), 
       dp[0][1] = 0;
    4) 确定遍历顺序: 由于当前状态与历史状态有关，因此需要i从小到大开始遍历。

<details>
<summary><font size="4" color="orange">Show Code</font></summary> 

``` c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0) return 0;

        vector<vector<int>> dp(prices.size() + 1, vector<int>(2));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = max(dp[i-1][1] - prices[i], dp[i-1][0]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
        }
        return max(dp[prices.size()-1][0], dp[prices.size()-1][1]);
    }
};
```
</details>

