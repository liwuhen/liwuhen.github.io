<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>璇玑</title><link>https://liwuhen.github.io/</link><description>Recent content on 璇玑</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 26 Jan 2024 17:38:13 +0000</lastBuildDate><atom:link href="https://liwuhen.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>C++类二篇</title><link>https://liwuhen.github.io/programming_languages/c++%E7%B1%BB%E4%BA%8C%E7%AF%87/</link><pubDate>Fri, 26 Jan 2024 17:38:13 +0000</pubDate><guid>https://liwuhen.github.io/programming_languages/c++%E7%B1%BB%E4%BA%8C%E7%AF%87/</guid><description/></item><item><title>C++类一篇</title><link>https://liwuhen.github.io/programming_languages/c++%E7%B1%BB%E4%B8%80%E7%AF%87/</link><pubDate>Fri, 26 Jan 2024 17:36:51 +0000</pubDate><guid>https://liwuhen.github.io/programming_languages/c++%E7%B1%BB%E4%B8%80%E7%AF%87/</guid><description/></item><item><title>C++指针</title><link>https://liwuhen.github.io/programming_languages/c++%E6%8C%87%E9%92%88/</link><pubDate>Fri, 26 Jan 2024 17:22:39 +0000</pubDate><guid>https://liwuhen.github.io/programming_languages/c++%E6%8C%87%E9%92%88/</guid><description>一 指针 1 单指针 1.1 声明指针 要声明指向特定类型的指针，请使用下面的格式：
typrName * pointerName; 1.2 指针赋值 应将内存地址赋给指针。可以对变量名应用&amp;amp;运算符，来获得被命名的内存的地址，new运算符返回未命名的内存的地址。
double * pn; // pn can point to a double value double * pa; // char * pc; // pc can point to a char value double bubble=3.2; pn = &amp;amp;bubble; // assign address of bubble to pn pc = new char; // assign address of newly allocated char memory to pc pa = new double[30]; //assign address of 1st element of array of 30 double to pa 1.</description></item><item><title>C++预处理</title><link>https://liwuhen.github.io/programming_languages/c++%E9%A2%84%E5%A4%84%E7%90%86/</link><pubDate>Fri, 26 Jan 2024 15:40:57 +0000</pubDate><guid>https://liwuhen.github.io/programming_languages/c++%E9%A2%84%E5%A4%84%E7%90%86/</guid><description>一 宏定义 1.1 无参数的宏定义(宏常量) 如果在程序中大量使用到了100这个值，那么为了方便管理，我们可以将其定义为： const int num = 100; 但是如果我们使用num定义一个数组，在不支持c99标准的编译器上是不支持的，因为num不是一个编译器常量，如果想得到了一个编译器常量，那么可以使用： #define num 100
在编译预处理时，将程序中在该语句以后出现的所有的num都用100代替。这种方法使用户能以一个简单的名字代替一个长的字符串，在预编译时将宏名替换成字符串的过程称为“宏展开”。
宏定义，只在宏定义的文件中起作用。
说明： 1) 宏名一般用大写，以便于与变量区别； 2) 宏定义可以是常数、表达式等； 3) 宏定义不作语法检查，只有在编译被宏展开后的源程序才会报错； 4) 宏定义不是C语言，不在行末加分号； 5) 宏名有效范围为从定义到本源文件结束； 6) 可以用#undef命令终止宏定义的作用域； 7) 在宏定义中，可以引用已定义的宏名； Show Code #define PI 3.1415 void test(){ double r = 10.0; double s = PI * r * r; printf(&amp;#34;s = %lf\n&amp;#34;, s); } 1.2 带参数的宏定义(宏函数) 在项目中，经常把一些短小而又频繁使用的函数写成宏函数，这是由于宏函数没有普通函数参数压栈、跳转、返回等的开销，可以调高程序的效率。
宏通过使用参数，可以创建外形和作用都与函数类似地类函数宏(function-like macro). 宏的参数也用圆括号括起来。
很显然，我们不会选择用函数来完成这个任务，原因有两个：首先，函数调用会带来额外的开销，它需要开辟一片栈空间，记录返回地址，将形参压栈，从函数返回还要释放堆栈。这种开销不仅会降低代码效率，而且代码量也会大大增加，而使用宏定义则在代码规模和速度方面都比函数更胜一筹；其次，函数的参数必须被声明为一种特定的类型，所以它只能在类型合适的表达式上使用，我们如果要比较两个浮点型的大小，就不得不再写一个专门针对浮点型的比较函数。反之，上面的那个宏定义可以用于整形、长整形、单浮点型、双浮点型以及其他任何可以用“&amp;gt;”操作符比较值大小的类型，也就是说，宏是与类型无关的。
注意: 1) 宏的名字中不能有空格，但是在替换的字符串中可以有空格。ANSI C允许在参数列表中使用空格； 2) 用括号括住每一个参数，并括住宏的整体定义。 3) 用大写字母表示宏的函数名。 4) 如果打算宏代替函数来加快程序运行速度。假如在程序中只使用一次宏对程序的运行时间没有太大提高。 Show Code #define SUM(x,y) (( x )+( y )) void test(){ //仅仅只是做文本替换 下例替换为 int ret = ((10)+(20)); //不进行计算 int ret = SUM(10, 20); printf(&amp;#34;ret:%d\n&amp;#34;,ret); } #define SUM(x,y) (( x )+( y )) void test(){ //仅仅只是做文本替换 下例替换为 int ret = ((10)+(20)); //不进行计算 int ret = SUM(10, 20); printf(&amp;#34;ret:%d\n&amp;#34;,ret); } 1.</description></item><item><title>关于</title><link>https://liwuhen.github.io/about_blog/about/</link><pubDate>Fri, 26 Jan 2024 15:25:42 +0000</pubDate><guid>https://liwuhen.github.io/about_blog/about/</guid><description/></item><item><title>生活</title><link>https://liwuhen.github.io/life/life/</link><pubDate>Fri, 26 Jan 2024 14:46:22 +0000</pubDate><guid>https://liwuhen.github.io/life/life/</guid><description/></item><item><title>C++基础知识</title><link>https://liwuhen.github.io/programming_languages/c++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Tue, 23 Jan 2024 10:28:54 +0000</pubDate><guid>https://liwuhen.github.io/programming_languages/c++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>一 命名空间 1.1 命名空间概念 命名空间为了防止名字冲突而引入的一种机制。系统中可以定义多个命名空间，每个命名空间都有自己的名字，名字可以不同。大家可以把命名空间看成一个作用域，我们在这个命名空间里定义函数，和另一个命名空间中函数即便同名，也不影响。
(1) 命名空间定义： namespace 命名空间名{ ...... } (2) 命名空间的定义可以不连续，甚至可以写在多个文件中。 (3) 外界如何访问命名空间中的函数? 格式：命名空间名::实体名 ----其中这::叫 ‘作用于运算符’ Show Code #include &amp;lt;iostream&amp;gt; #include &amp;#34;project3.hpp&amp;#34; namespace zhangsan { void radius() { printf(&amp;#34;shangsan 的radius()函数&amp;#34;); } } int main() { zhangsan::radius(); lisi::radius(); return 0; // main()中返回值一般表示状态，返回0表示成功，非0一般不表示错误 } 二 输入输出流 2.1 基本的输入输出流 c++中我们不是用printf，使用cout,c++的标准库 (1) std:: 命名空间，标准库的命名空间 (2) std::endl 作用： a) 输出换行符 \n b) 强制刷新输出缓冲区，缓冲区的所有数据都被系统清除。 (3) std::cin 基本输入 &amp;raquo;输入运算符 &amp;laquo;输出运算符
Show Code #include &amp;lt;iostream&amp;gt; #include &amp;#34;project3.</description></item><item><title>量产级-泊车位角点检测</title><link>https://liwuhen.github.io/parking/parking_slot_detect/</link><pubDate>Sat, 20 Jan 2024 06:37:29 +0000</pubDate><guid>https://liwuhen.github.io/parking/parking_slot_detect/</guid><description>车位角点检测模型 布式系列的第三篇博客中，简单探讨了有关“分布式互斥”的相关知识，也从中领悟了”有你没我，有我没你“的设计精髓。分布式互斥算法主要是为了解决同一临界资源同一时刻只能被一个程序访问的问题。
如果进一步思考可以发现，在之前介绍的算法中，主要讲了如何协调多个进程获取权限和根据权限有序访问共享资源，“获得访问权限的进程可以访问共享资源，其他进程必须等待拥有该权限的进程释放权限”。但是，并没有介绍在访问共享资源时，这个权限是如何设置或产生的，以及设置或产生这个权限的工作原理是什么。
那么，就带着好奇心，一起来看看分布式锁是如何解决这个问题的。
分布式锁的用途 首先，我们需要重新认识一下什么是“锁”。
在单机系统中，经常会有多个线程访问同一种资源的情况，按照习惯，我们把这样的资源叫作共享资源，或者临界资源。为了维护线程操作的有效性和正确性，自然而就需要某种机制来减少低效率的操作，避免同时对相同的数据进行不一样的操作，要维护数据的一致性，防止数据脏读和数据丢失等。也就是说，我们需要一种互斥机制，按照某种规则对多个线程进行排队，依次、互不干扰地访问共享资源。
这个机制指的是，为了实现分布式互斥，在某个地方做标记，这个标记每个线程都能看到，到标记不存在时可以设置该标记，当标记被设置后，其他线程只能等待拥有该标记的线程执行完成，并释放该标记后，才能去设置该标记和访问共享资源。这个标记也就是我们常常说的锁。
简单来说，锁是多线程同时访问同一资源的场景下，为了让线程互不干扰地访问共享资源，从而保证操作的有效性和正确性的一种标记。
与普通锁不同的是，分布式锁是指分布式环境下，系统部署在多个机器中，实现多进程分布式互斥的一种锁。为了保证多个进程能看到锁，锁被存在公共存储（比如 Redis、Memcached 等三方存储中），以实现多个进程并发访问同一共享资源，同一时刻只有一个进程可以访问共享资源，确保数据的一致性。</description></item><item><title>行车</title><link>https://liwuhen.github.io/noa/first/</link><pubDate>Sat, 20 Jan 2024 05:38:26 +0000</pubDate><guid>https://liwuhen.github.io/noa/first/</guid><description>NOA Test Test01 This is a test.</description></item></channel></rss>