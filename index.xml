<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>璇玑</title><link>https://liwuhen.cn/</link><description>Recent content on 璇玑</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 10 Feb 2024 10:17:43 +0000</lastBuildDate><atom:link href="https://liwuhen.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>CUDA篇-Cuda Driver API</title><link>https://liwuhen.cn/model_deploy/cuda_driverapi/</link><pubDate>Sat, 10 Feb 2024 10:17:43 +0000</pubDate><guid>https://liwuhen.cn/model_deploy/cuda_driverapi/</guid><description>一、Driver API CUDA Driver是GPU驱动级底层API随显卡驱动发布，CUDA Driver的头文件与动态库对应于：cuda.h 和 libcuda.so Driver API 主要知识点是 Context 的管理机制 以及 CUDA 系列接口的开发习惯(错误检查方法), 还有内存模型。
参考连接：nvcc, cuda driver,cudatoolkit,cudnn</description></item><item><title>单调栈</title><link>https://liwuhen.cn/datastruct/monotonic_stack/</link><pubDate>Sun, 04 Feb 2024 03:24:30 +0000</pubDate><guid>https://liwuhen.cn/datastruct/monotonic_stack/</guid><description>一、单调栈 1.1 每日温度 题目： 每日温度
分析：由题目含义，可知寻找数组中每个元素右边第一个比它大的元素索引。可知此题维护一个单调递增栈即可。 每一个索引下标i与栈顶元素比较，当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况，元素入栈； 当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况，元素入栈； 当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况，栈内元素出栈，元素T[i]入栈。
Show Code class Solution { public: vector&amp;lt;int&amp;gt; dailyTemperatures(vector&amp;lt;int&amp;gt;&amp;amp; temperatures) { // 递增栈 stack&amp;lt;int&amp;gt; st; vector&amp;lt;int&amp;gt; result(temperatures.size(), 0); st.push(0); for (int i = 1; i &amp;lt; temperatures.size(); i++) { if (temperatures[i] &amp;lt; temperatures[st.top()]) { st.push(i); } else if (temperatures[i] == temperatures[st.top()]) { st.push(i); } else { while(!st.empty() &amp;amp;&amp;amp; temperatures[i] &amp;gt; temperatures[st.top()]) { result[st.top()] = i - st.top(); st.pop(); } st.push(i); } } return result; } }; 1.</description></item><item><title>动态规划II</title><link>https://liwuhen.cn/datastruct/dynamic_programmingv2/</link><pubDate>Fri, 02 Feb 2024 03:25:45 +0000</pubDate><guid>https://liwuhen.cn/datastruct/dynamic_programmingv2/</guid><description>一 子序列问题 1.1 最长递增子序列 题目： 300.最长递增子序列
分析：一般动态规划问题，考虑拆分子问题与历史状态。当前下标i的递增子序列长度，其实和i之前的下标j的子序列长度有关系。
考虑动规五步曲： 1）dp数组的含义：dp[i]，表示i之前包括i的以nums[i]结尾的最长递增子序列的长度。 2）递推公式：如何通过历史状态递推出当前状态dp[i]。 位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值(为什么单独变量j遍历？ 因为子序列不连续，可能存在nums[i]&amp;lt;nums[i-1]情况，此时若采用dp[i] = dp[i-1] + 1思路，此时dp[i]等于初始化的值, 导致后续遍历无法联系i之前的状态,相当于冲i处视作子序列的开头位置)。 递推公式：dp[i] = max(dp[i], dp[j]+1); 3) dp数组初始化：dp[0] = 1, 只考虑数组的第一个元素。dp数组应该初始化为1,因为无论dp[i] 中i取值如何，至少长度为1,就是nums[i]本身。 4) 确定遍历顺序: 由于当前状态与历史状态有关，因此需要i从小到大开始遍历。 Show Code class Solution { public: int lengthOfLIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() &amp;lt;= 1) return nums.size(); vector&amp;lt;int&amp;gt; dp(nums.size(), 1); dp[0] = 1; int result = 0; for (int i = 1; i &amp;lt; nums.size(); i++) { for (int j = 0; j &amp;lt; i; j++) { if (nums[i] &amp;gt; nums[j]) { dp[i] = max(dp[i], dp[j]+1); } } result = max(result, dp[i]); } return result; } }; 1.</description></item><item><title>动态规划I</title><link>https://liwuhen.cn/datastruct/dynamic_programming/</link><pubDate>Tue, 30 Jan 2024 01:44:57 +0000</pubDate><guid>https://liwuhen.cn/datastruct/dynamic_programming/</guid><description>一 状态机DP 1.1 打家劫舍 题目：198.打家劫舍
分析：此题考虑偷某个房屋和相邻的房屋有关系，例如示例1最后一个房屋和前一房屋有关，当前房屋偷与不偷取决于 前一个房屋和前两个房屋是否被偷了。因此，抽象理解当前状态和前面状态会有一种依赖关系，一般考虑动态规划。
考虑动规五步曲： 1）dp数组的含义：dp[i]，考虑当前房屋i（包含i之前的房屋）,偷窃的最高金额。 2）递推公式：如何通过历史状态递推出当前状态dp[i]。当前第i的房屋分为2种状态：选与不选？ a）选，选i房屋时，最大金额 = dp[i-2] + nums[i]。 b)不选，不选i房屋时，最大金额 = dp[i-1]。 这里dp[i-1]表示考虑i-1房屋即i-1之前房屋的最大金额，具体偷不偷不一定。 递推公式：dp[i] = max(dp[i-2]+nums[i], dp[i-1]); 3) dp数组初始化：dp[0] = nums[0], 只考虑第一个房屋，最大值为nums[0], dp[1] = max(nums[0], nums[1]),因为对于第2房屋，并不一定偷，若不偷的可能偷1房屋，因此选最大。 4) 确定遍历顺序: 由于当前状态与历史状态有关，因此需要i从小到大开始遍历。 Show Code class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; vector&amp;lt;int&amp;gt; dp(nums.size()+1, 0); dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (int i = 2; i &amp;lt; nums.</description></item><item><title>C++类二篇</title><link>https://liwuhen.cn/programming_languages/c++%E7%B1%BB%E4%BA%8C%E7%AF%87/</link><pubDate>Fri, 26 Jan 2024 17:38:13 +0000</pubDate><guid>https://liwuhen.cn/programming_languages/c++%E7%B1%BB%E4%BA%8C%E7%AF%87/</guid><description>五 拷贝构造函数 5.1 默认情况下，类对象的拷贝是每个成员变量逐个拷贝。 5.2 拷贝构造函数 (1) 如果一个类的构造函数，它的第一个参数是所属的类类对象引用，如果还有其他额外参数，这些额外参数都有默认值。 函数默认参数都必须放在函数声明中，除非该函数没有函数声明。 (2) 拷贝构造函数：在一定的时机被系统自动调用，时机：进行对象复制的时候 = (3) 建议拷贝构造函数第一个参数带const, 且一般不要声明explicit来禁止隐式类型转换。 (4)（一中，默认情况下，类对象的拷贝是每个成员变量逐个拷贝。）成员变量逐个拷贝功能。 因为我们定义的拷贝构造函数存在而失去作用。我们定义的拷贝构造函数取代了系统默认的拷贝构造函数。 (5) 当自定义拷贝构造函数，且类内存在有参构造函数时，不能使用Time myTime01=Time(12,12,12); 初始化类对象。 5.3 系统默认的拷贝构造函数 (1) 如果我们没有定义一个拷贝构造函数，编译器会帮我们定义一个拷贝构造函数 (2) 编译器给我们定义的叫“合成拷贝构造函数” --作用将拷贝构造函数中第一个参数类对象的引用的成员逐个拷贝到正在创建的对象中。 (3) 默认拷贝构造：每个成员的类型决定自身如何拷贝，比如说成员属性是int类型，那么就是直接的值拷贝。 如果成员是其他类对象，就会调用类的拷贝构造函数。 (4) 如果自己定义了拷贝构造函数，就会取代系统的拷贝构造函数，那么就需要在拷贝构造函数中赋值。 以防止出现未初始化的成员变量。 5.4 还有一些情况会调用拷贝构造函数的调用 (1) 函数传递参数 将一个实参传递给一个非引用类型形参，会先调用构造函数构造出对象，然后调用拷贝构造函数。 (2) 函数返回值是一个局部对象类对象，会进行临时对象的拷贝，调用拷贝构造函数创建一个临时对象返回。 5.5 赋值与初始化的区别 (1) 赋值与初始化的区别：初始化是指创建这个对象的时刻对它进行一些成员变量的定义、赋值等， 例如常见的初始化有拷贝构造初始化，默认构造初始化，有参构造初始化；赋值是指对已经初始化好了的对象进行值的修改变动， 将已经初始化了的一个对象的参数赋给另一个已经初始化了的对象。 //person是用户自定义类类型 person p1=p2;//此处为拷贝初始化，即创建一个p1对象，使用创建好的p2对象对它进行拷贝初始化 person p3;//调用默认构造函数初始化p1对象 p3=p1;//将p1对象赋值给已经初始化好的p3对象 person p4(30,&amp;quot;老王&amp;quot;);//调用有参构造初始化p4对象 p4=p1;//将p1的成员数据赋值给p4，即改变p4的年龄与姓名 (2) 调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。 如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符。 Show Code #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;#34;project3.</description></item><item><title>C++类一篇</title><link>https://liwuhen.cn/programming_languages/c++%E7%B1%BB%E4%B8%80%E7%AF%87/</link><pubDate>Fri, 26 Jan 2024 17:36:51 +0000</pubDate><guid>https://liwuhen.cn/programming_languages/c++%E7%B1%BB%E4%B8%80%E7%AF%87/</guid><description>一 成员函数、对象复制与私有方法 1.1 综述：类是我们自己定义的数据类型（新类型） 类是我们自己定义的数据类型，新类型 设计类需要考虑的角度 (1) 站在设计和实现的角度--stl模板类的设计者 (2) 站在使用者的角度--哪些是提供给我们的接口 (3) 继承的角度，父类和子类 公共特性由父类来实现 1.2 类基础 (1) 一个类就是用户自己定义的数据类型，我们可以把类想象成一个命名空间，包着一堆东西（成员函数、成员变量） (2)一个类的组成，成员变量（属性）成员函数--由很多特殊的成员函数（构造，析构）和成员属性（this指针） (3) 访问类成员的时候，如果是类对象，就是用 对象名.成员名 来访问 如果使用指向对象的指针来访问，就使用 对象指针-&amp;gt;成员属性 (4) public成员提供类的接口，给外部使用，private成员提供各种实现类功能的细节方法。 但是不暴露给使用者，外界无法使用这些成员函数，只能在类内部使用 (5) struct的成员函数和属性默认是public。class定义的结构默认是private的。 1.3 成员函数 1.4 对象的拷贝 (1) 对象拷贝--本质上是调用拷贝构造函数--类的成员函数 (2) 默认情况下，这种对象的拷贝，是每个成员属性逐个拷贝 (3) 在后面如果在Time中定义适当的“赋值运算符”就能实现这种拷贝行为。---&amp;gt;运算符重载 Show Code #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;#34;project3.hpp&amp;#34; #include &amp;#34;project2.h&amp;#34; using namespace std; class Student { public: int number; int age; }; class Time //定义一个时间类 { public: int Hour; int Minute; int Second; private: //int MilliSecond;//私有的成员属性，不可以在外部访问 //成员函数 public: Time(){} //默认构造函数 Time(int TemHour, int TemMinute, int TemSecond) // 重载 { Hour = TemHour; Minute = TemMinute; Second = TemSecond; } // 一个普通的成员属性初始化方法 void InitTime( int TemHour, int TemMinute, int TemSecond) { Hour = TemHour; Minute = TemMinute; Second = TemSecond; } }; //初始化时间类的函数--c语言风格的写法 void InitTime(Time&amp;amp;TemTime/*输出参数*/, int TemHour, int TemMinute, int TemSecond) { TemTime.</description></item><item><title>C++指针</title><link>https://liwuhen.cn/programming_languages/c++%E6%8C%87%E9%92%88/</link><pubDate>Fri, 26 Jan 2024 17:22:39 +0000</pubDate><guid>https://liwuhen.cn/programming_languages/c++%E6%8C%87%E9%92%88/</guid><description>一 指针 1 单指针 1.1 声明指针 要声明指向特定类型的指针，请使用下面的格式：
typrName * pointerName; 1.2 指针赋值 应将内存地址赋给指针。可以对变量名应用&amp;amp;运算符，来获得被命名的内存的地址，new运算符返回未命名的内存的地址。
double * pn; // pn can point to a double value double * pa; // char * pc; // pc can point to a char value double bubble=3.2; pn = &amp;amp;bubble; // assign address of bubble to pn pc = new char; // assign address of newly allocated char memory to pc pa = new double[30]; //assign address of 1st element of array of 30 double to pa 1.</description></item><item><title>C++预处理</title><link>https://liwuhen.cn/programming_languages/c++%E9%A2%84%E5%A4%84%E7%90%86/</link><pubDate>Fri, 26 Jan 2024 15:40:57 +0000</pubDate><guid>https://liwuhen.cn/programming_languages/c++%E9%A2%84%E5%A4%84%E7%90%86/</guid><description>一 宏定义 1.1 无参数的宏定义(宏常量) 如果在程序中大量使用到了100这个值，那么为了方便管理，我们可以将其定义为： const int num = 100; 但是如果我们使用num定义一个数组，在不支持c99标准的编译器上是不支持的，因为num不是一个编译器常量，如果想得到了一个编译器常量，那么可以使用： #define num 100
在编译预处理时，将程序中在该语句以后出现的所有的num都用100代替。这种方法使用户能以一个简单的名字代替一个长的字符串，在预编译时将宏名替换成字符串的过程称为“宏展开”。
宏定义，只在宏定义的文件中起作用。
说明： 1) 宏名一般用大写，以便于与变量区别； 2) 宏定义可以是常数、表达式等； 3) 宏定义不作语法检查，只有在编译被宏展开后的源程序才会报错； 4) 宏定义不是C语言，不在行末加分号； 5) 宏名有效范围为从定义到本源文件结束； 6) 可以用#undef命令终止宏定义的作用域； 7) 在宏定义中，可以引用已定义的宏名； Show Code #define PI 3.1415 void test(){ double r = 10.0; double s = PI * r * r; printf(&amp;#34;s = %lf\n&amp;#34;, s); } 1.2 带参数的宏定义(宏函数) 在项目中，经常把一些短小而又频繁使用的函数写成宏函数，这是由于宏函数没有普通函数参数压栈、跳转、返回等的开销，可以调高程序的效率。
宏通过使用参数，可以创建外形和作用都与函数类似地类函数宏(function-like macro). 宏的参数也用圆括号括起来。
很显然，我们不会选择用函数来完成这个任务，原因有两个：首先，函数调用会带来额外的开销，它需要开辟一片栈空间，记录返回地址，将形参压栈，从函数返回还要释放堆栈。这种开销不仅会降低代码效率，而且代码量也会大大增加，而使用宏定义则在代码规模和速度方面都比函数更胜一筹；其次，函数的参数必须被声明为一种特定的类型，所以它只能在类型合适的表达式上使用，我们如果要比较两个浮点型的大小，就不得不再写一个专门针对浮点型的比较函数。反之，上面的那个宏定义可以用于整形、长整形、单浮点型、双浮点型以及其他任何可以用“&amp;gt;”操作符比较值大小的类型，也就是说，宏是与类型无关的。
注意: 1) 宏的名字中不能有空格，但是在替换的字符串中可以有空格。ANSI C允许在参数列表中使用空格； 2) 用括号括住每一个参数，并括住宏的整体定义。 3) 用大写字母表示宏的函数名。 4) 如果打算宏代替函数来加快程序运行速度。假如在程序中只使用一次宏对程序的运行时间没有太大提高。 Show Code #define SUM(x,y) (( x )+( y )) void test(){ //仅仅只是做文本替换 下例替换为 int ret = ((10)+(20)); //不进行计算 int ret = SUM(10, 20); printf(&amp;#34;ret:%d\n&amp;#34;,ret); } #define SUM(x,y) (( x )+( y )) void test(){ //仅仅只是做文本替换 下例替换为 int ret = ((10)+(20)); //不进行计算 int ret = SUM(10, 20); printf(&amp;#34;ret:%d\n&amp;#34;,ret); } 1.</description></item><item><title>关于</title><link>https://liwuhen.cn/about_blog/about/</link><pubDate>Fri, 26 Jan 2024 15:25:42 +0000</pubDate><guid>https://liwuhen.cn/about_blog/about/</guid><description/></item><item><title>生活</title><link>https://liwuhen.cn/life/life/</link><pubDate>Fri, 26 Jan 2024 14:46:22 +0000</pubDate><guid>https://liwuhen.cn/life/life/</guid><description/></item><item><title>C++基础知识</title><link>https://liwuhen.cn/programming_languages/c++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Tue, 23 Jan 2024 10:28:54 +0000</pubDate><guid>https://liwuhen.cn/programming_languages/c++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>一 命名空间 1.1 命名空间概念 命名空间为了防止名字冲突而引入的一种机制。系统中可以定义多个命名空间，每个命名空间都有自己的名字，名字可以不同。大家可以把命名空间看成一个作用域，我们在这个命名空间里定义函数，和另一个命名空间中函数即便同名，也不影响。
(1) 命名空间定义： namespace 命名空间名{ ...... } (2) 命名空间的定义可以不连续，甚至可以写在多个文件中。 (3) 外界如何访问命名空间中的函数? 格式：命名空间名::实体名 ----其中这::叫 ‘作用于运算符’ Show Code #include &amp;lt;iostream&amp;gt; #include &amp;#34;project3.hpp&amp;#34; namespace zhangsan { void radius() { printf(&amp;#34;shangsan 的radius()函数&amp;#34;); } } int main() { zhangsan::radius(); lisi::radius(); return 0; // main()中返回值一般表示状态，返回0表示成功，非0一般不表示错误 } 二 输入输出流 2.1 基本的输入输出流 c++中我们不是用printf，使用cout,c++的标准库 (1) std:: 命名空间，标准库的命名空间 (2) std::endl 作用： a) 输出换行符 \n b) 强制刷新输出缓冲区，缓冲区的所有数据都被系统清除。 (3) std::cin 基本输入 &amp;raquo;输入运算符 &amp;laquo;输出运算符
Show Code #include &amp;lt;iostream&amp;gt; #include &amp;#34;project3.</description></item><item><title>量产级-泊车位角点检测</title><link>https://liwuhen.cn/parking/parking_slot_detect/</link><pubDate>Sat, 20 Jan 2024 06:37:29 +0000</pubDate><guid>https://liwuhen.cn/parking/parking_slot_detect/</guid><description>车位角点检测模型</description></item><item><title>行车</title><link>https://liwuhen.cn/noa/first/</link><pubDate>Sat, 20 Jan 2024 05:38:26 +0000</pubDate><guid>https://liwuhen.cn/noa/first/</guid><description>NOA Test Test01 This is a test.</description></item></channel></rss>