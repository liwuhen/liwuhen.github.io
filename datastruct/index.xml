<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Datastructs on 璇玑</title><link>https://liwuhen.cn/datastruct/</link><description>Recent content in Datastructs on 璇玑</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 04 Feb 2024 03:24:30 +0000</lastBuildDate><atom:link href="https://liwuhen.cn/datastruct/index.xml" rel="self" type="application/rss+xml"/><item><title>单调栈</title><link>https://liwuhen.cn/datastruct/monotonic_stack/</link><pubDate>Sun, 04 Feb 2024 03:24:30 +0000</pubDate><guid>https://liwuhen.cn/datastruct/monotonic_stack/</guid><description>一、单调栈 1.1 每日温度 题目： 每日温度
分析：由题目含义，可知寻找数组中每个元素右边第一个比它大的元素索引。可知此题维护一个单调递增栈即可。 每一个索引下标i与栈顶元素比较，当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况，元素入栈； 当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况，元素入栈； 当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况，栈内元素出栈，元素T[i]入栈。
Show Code class Solution { public: vector&amp;lt;int&amp;gt; dailyTemperatures(vector&amp;lt;int&amp;gt;&amp;amp; temperatures) { // 递增栈 stack&amp;lt;int&amp;gt; st; vector&amp;lt;int&amp;gt; result(temperatures.size(), 0); st.push(0); for (int i = 1; i &amp;lt; temperatures.size(); i++) { if (temperatures[i] &amp;lt; temperatures[st.top()]) { st.push(i); } else if (temperatures[i] == temperatures[st.top()]) { st.push(i); } else { while(!st.empty() &amp;amp;&amp;amp; temperatures[i] &amp;gt; temperatures[st.top()]) { result[st.top()] = i - st.top(); st.pop(); } st.push(i); } } return result; } }; 1.</description></item><item><title>动态规划II</title><link>https://liwuhen.cn/datastruct/dynamic_programmingv2/</link><pubDate>Fri, 02 Feb 2024 03:25:45 +0000</pubDate><guid>https://liwuhen.cn/datastruct/dynamic_programmingv2/</guid><description>一 子序列问题 1.1 最长递增子序列 题目： 300.最长递增子序列
分析：一般动态规划问题，考虑拆分子问题与历史状态。当前下标i的递增子序列长度，其实和i之前的下标j的子序列长度有关系。
考虑动规五步曲： 1）dp数组的含义：dp[i]，表示i之前包括i的以nums[i]结尾的最长递增子序列的长度。 2）递推公式：如何通过历史状态递推出当前状态dp[i]。 位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值(为什么单独变量j遍历？ 因为子序列不连续，可能存在nums[i]&amp;lt;nums[i-1]情况，此时若采用dp[i] = dp[i-1] + 1思路，此时dp[i]等于初始化的值, 导致后续遍历无法联系i之前的状态,相当于冲i处视作子序列的开头位置)。 递推公式：dp[i] = max(dp[i], dp[j]+1); 3) dp数组初始化：dp[0] = 1, 只考虑数组的第一个元素。dp数组应该初始化为1,因为无论dp[i] 中i取值如何，至少长度为1,就是nums[i]本身。 4) 确定遍历顺序: 由于当前状态与历史状态有关，因此需要i从小到大开始遍历。 Show Code class Solution { public: int lengthOfLIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() &amp;lt;= 1) return nums.size(); vector&amp;lt;int&amp;gt; dp(nums.size(), 1); dp[0] = 1; int result = 0; for (int i = 1; i &amp;lt; nums.size(); i++) { for (int j = 0; j &amp;lt; i; j++) { if (nums[i] &amp;gt; nums[j]) { dp[i] = max(dp[i], dp[j]+1); } } result = max(result, dp[i]); } return result; } }; 1.</description></item><item><title>动态规划I</title><link>https://liwuhen.cn/datastruct/dynamic_programming/</link><pubDate>Tue, 30 Jan 2024 01:44:57 +0000</pubDate><guid>https://liwuhen.cn/datastruct/dynamic_programming/</guid><description>一 状态机DP 1.1 打家劫舍 题目：198.打家劫舍
分析：此题考虑偷某个房屋和相邻的房屋有关系，例如示例1最后一个房屋和前一房屋有关，当前房屋偷与不偷取决于 前一个房屋和前两个房屋是否被偷了。因此，抽象理解当前状态和前面状态会有一种依赖关系，一般考虑动态规划。
考虑动规五步曲： 1）dp数组的含义：dp[i]，考虑当前房屋i（包含i之前的房屋）,偷窃的最高金额。 2）递推公式：如何通过历史状态递推出当前状态dp[i]。当前第i的房屋分为2种状态：选与不选？ a）选，选i房屋时，最大金额 = dp[i-2] + nums[i]。 b)不选，不选i房屋时，最大金额 = dp[i-1]。 这里dp[i-1]表示考虑i-1房屋即i-1之前房屋的最大金额，具体偷不偷不一定。 递推公式：dp[i] = max(dp[i-2]+nums[i], dp[i-1]); 3) dp数组初始化：dp[0] = nums[0], 只考虑第一个房屋，最大值为nums[0], dp[1] = max(nums[0], nums[1]),因为对于第2房屋，并不一定偷，若不偷的可能偷1房屋，因此选最大。 4) 确定遍历顺序: 由于当前状态与历史状态有关，因此需要i从小到大开始遍历。 Show Code class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; vector&amp;lt;int&amp;gt; dp(nums.size()+1, 0); dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (int i = 2; i &amp;lt; nums.</description></item></channel></rss>