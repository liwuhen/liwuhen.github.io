<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Datastructs on 璇玑</title><link>https://liwuhen.cn/datastruct/</link><description>Recent content in Datastructs on 璇玑</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 30 Jan 2024 01:44:57 +0000</lastBuildDate><atom:link href="https://liwuhen.cn/datastruct/index.xml" rel="self" type="application/rss+xml"/><item><title>动态规划I</title><link>https://liwuhen.cn/datastruct/dynamic_programming/</link><pubDate>Tue, 30 Jan 2024 01:44:57 +0000</pubDate><guid>https://liwuhen.cn/datastruct/dynamic_programming/</guid><description>一 状态机DP 1.1 打家劫舍 题目：198.打家劫舍
分析：此题考虑偷某个房屋和相邻的房屋有关系，例如示例1最后一个房屋和前一房屋有关，当前房屋偷与不偷取决于 前一个房屋和前两个房屋是否被偷了。因此，抽象理解当前状态和前面状态会有一种依赖关系，一般考虑动态规划。
考虑动规五步曲： 1）dp数组的含义：dp[i]，考虑当前房屋i（包含i之前的房屋）,偷窃的最高金额。 2）递推公式：如何通过历史状态递推出当前状态dp[i]。当前第i的房屋分为2种状态：选与不选？ a）选，选i房屋时，最大金额 = dp[i-2] + nums[i]。 b)不选，不选i房屋时，最大金额 = dp[i-1]。 这里dp[i-1]表示考虑i-1房屋即i-1之前房屋的最大金额，具体偷不偷不一定。 递推公式：dp[i] = max(dp[i-2]+nums[i], dp[i-1]); 3) dp数组初始化：dp[0] = nums[0], 只考虑第一个房屋，最大值为nums[0], dp[1] = max(nums[0], nums[1]),因为对于第2房屋，并不一定偷，若不偷的可能偷1房屋，因此选最大。 4) 确定遍历顺序: 由于当前状态与历史状态有关，因此需要i从小到大开始遍历。 Show Code class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; vector&amp;lt;int&amp;gt; dp(nums.size()+1, 0); dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (int i = 2; i &amp;lt; nums.</description></item></channel></rss>